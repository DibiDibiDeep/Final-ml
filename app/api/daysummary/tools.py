import os
from dotenv import load_dotenv
import requests
import logging
from datetime import datetime

from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import tool
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate, PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from openai import OpenAI

from .config import collection
from pymilvus import (
    RRFRanker,
)

import json
from langchain.chains.query_constructor.base import AttributeInfo
from langchain.retrievers.self_query.base import SelfQueryRetriever

from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser
import os

llm_model = os.getenv("LLM_MODEL")
openai_key = os.getenv("OPENAI_API_KEY")


@tool
def classify_intent(query: str) -> str:
    """
    This function classifies the intent of a given query.
    Parameters:
    query (str): The query input by the user
    Returns:
    str: 'QUESTION', 'DIARY_REQUEST', 'DIARY_SAVE', 'SHARING'
    """
    llm = ChatOpenAI(
        model_name="gpt-4o-mini",
        openai_api_key=os.getenv("OPENAI_API_KEY"),
        temperature=0,
    )
    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                """
                Classify the user's query into one of these categories:
                1. QUESTION:
                   - For inquiries about specific events, activities, or details of the parent's or child's day.
                   - Examples: "What did my baby eat today?", "Did my child nap well at daycare?"

                2. DIARY_REQUEST:
                   - When the user explicitly asks to write or create a diary entry.
                   - Examples: "Can you help me write a diary for today?", "I want to make a diary entry."

                3. SHARING:
                   - When the user shares their personal experiences, feelings, or observations about their day or their child's day.
                   - Examples: "My baby smiled for the first time today!", "I felt overwhelmed with work and childcare today."

                4. DIARY_SAVE:
                   - When the user explicitly requests to save or store a written diary entry.
                   - Examples: "Please save this diary entry", "Can you store this in my diary?"

                Instructions for classification:
                1. Carefully read and analyze the user's query.
                2. Identify key words or phrases that align with one of the above categories.
                3. Consider the overall context and intent of the query.
                4. Select the most appropriate category based on your analysis.
                5. Return only the category name in uppercase (e.g., "QUESTION", "DIARY_REQUEST", "SHARING", or "DIARY_SAVE").

                Note: If the query seems to fit multiple categories, choose the one that best represents the primary intent of the user.
                """
            ),
            ("user", "{query}"),
        ]
    )
    chain = prompt | llm
    response = chain.invoke({"query": query})
    return response.content.strip().upper()

llm_model = os.getenv("LLM_MODEL")
embedding_model = os.getenv("EMBEDDING_MODEL")

embedding_client = OpenAI(api_key=openai_key)

# Set up logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

@tool
def emphaty_assistant(query: str) -> str:
    """
    This tool is used to generate empathetic responses to user queries.
    Parameters:
    query (str): The user's query
    Returns:
    str: The empathetic response generated by the assistant
    """
    chain = (
        PromptTemplate.from_template(
        """You are an assistant capable of empathizing with and comforting the user about events and emotions they experienced during their day.
        Listen carefully to the user's story and respond as follows:
        - First, express empathy and understanding for the user's shared content.
        - Briefly summarize the shared content to show that you've understood correctly.
        - Provide an open-ended comment to give the user an opportunity to share more.
        - When asking follow-up questions, focus on the parent's feelings and the child's activities.
            - For the parent: Ask about their personal experiences, feelings, and reflections.
            - For the child: Ask questions that encourage the parent to share more about the child's activities and behaviors.
                - If the content is about the child and it's unclear whether the parent and child were together during the activity, ask questions like:
                    - How did your child feel during this activity?
                    - What do you think was the most memorable part for your child?
        - Always generate responses in a kind and polite manner in Korean.

        Query: {query}
        Answer:"""
    )
    # OpenAI의 LLM을 사용합니다.
    | ChatOpenAI(
        model=llm_model,
        openai_api_key=openai_key,)
    | StrOutputParser()
    )

    return chain.invoke({"query": query})

def get_embedding(client, text, model=embedding_model):
    text = text.replace("\n", " ")
    return client.embeddings.create(input=[text], model=model).data[0].embedding

# 하이브리드 쿼리 검색 함수
@tool
def retriever_assistant(input_str: str) -> str:
    """
    Use this tool when you need to find specific information about the parent's or child's events.
    Retrieves information about the parent's or child's day and activities and generates a response.
    
    args:
        input_str:str {"user_id",int, "baby_id":int, "query":str}
    returns:
        str: Retrieved information or a message indicating no information is available.
    """
    if "{" not in input_str:
        input_str = "{" + input_str + "}"
    input_json = json.loads(input_str)
    user_id = input_json['user_id']
    baby_id = input_json['baby_id']
    query = input_json['query']
    today_date = datetime.now().strftime("%Y-%m-%d")

    logging.info(f"Input parameters - user_id: {user_id}, baby_id: {baby_id}, query: {query}, today_date: {today_date}")
    llm = ChatOpenAI(
        openai_api_key=openai_key,
        model= llm_model,
        temperature=0.0,
    )
    template = """
        Given the following search query: "{query}"
    Generate a Milvus expression to filter the search results. The expression should be based on the fields available in the collection:
    - user_id (INT64){user_id}, baby_id (INT64){baby_id}
    - date (VARCHAR, format: "YYYY-MM-DD")
      - If the user mentions "today", use today's date ({today_date}) to generate the response.
      - If the user mentions a specific date, use that date in the format "YYYY-MM-DD".
      - If the user mentions only a day of the week, month, or year, use the corresponding part from today's date ({today_date}) to complete the date.
      - If no date information is provided in the query, use today's date ({today_date}).
      - Always include the date in the expression unless the query is clearly not related to any specific date.
    - role (VARCHAR)
      - role is 'parents' or 'child'
      - If the query is about the user's activities, use role == 'parents'
      - If the query is about the user's child's activities, use role == 'child'
    If two expressions need to be used, connect the expressions with 'and'.
    Return only the expression, without any explanation, additional text, or backticks.
    
    Example 1:
    - Query: user_id: {user_id}, baby_id: {baby_id}, "What did I eat for dinner today?"
    - Expression: user_id == {user_id} and baby_id == {baby_id} and date == '{today_date}' and role == 'parents'

    Example 2:
    - Query: user_id: {user_id}, baby_id: {baby_id}, "Did I go to the park with my friends today?"
    - Expression: user_id == {user_id} and baby_id == {baby_id} and date == '{today_date}' and role == 'parents'
    """
    prompt = PromptTemplate.from_template(template)

    chain = prompt | llm | StrOutputParser()

    # 쿼리 표현식 생성
    expr = chain.invoke({"query": query, "today_date": today_date, "user_id": user_id, "baby_id": baby_id})
    logging.info(f"Generated expression: {expr}")
    # 쿼리 임베딩
    query_embeddings = get_embedding(embedding_client, query)

    res = collection.search(
        [query_embeddings],
        expr=expr,
        anns_field="embedding",
        param={
            "metric_type": "COSINE",
            "params": {"nprobe": 10},
        },  # COSINE 메트릭 타입 사용
        rerank=RRFRanker(),
        limit=1,
        output_fields=["date", "text"],
    )
    if len(res[0]) == 0:
        return  "No results found"
    return res

@tool
def save_diary(user_id: int, baby_id: int, content: str) -> bool:
    """Use this when you want to POST to a Backend API.
    Be careful to always use double quotes for strings in the json string
    The output will be the text response of the POST request.
    If the response is successful, the function will return true.
    After a successful response, stop using this tool and inform the user about the successful save.
    """
    backend_url = os.getenv("BACKEND_API_URL")
    headers = {
        "Content-Type": "application/json",
    }
    data = {
        "userId": user_id,
        "babyId": baby_id,
        "content": content,
        "date": datetime.now().strftime("%Y-%m-%d")
    }
    logging.info(f"Data to be saved: {data} ,Data type: {type(data)}")
    try:
        response = requests.post(backend_url + "/api/today-sum", json=data, headers=headers)
        # logging.info(f"Response from backend: {data}")
        return True
    except requests.exceptions.RequestException as e:
        # logging.error(f"Error saving diary: {str(e)}")
        return False